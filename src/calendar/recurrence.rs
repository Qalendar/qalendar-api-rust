use chrono::{DateTime, Utc, Duration, TimeZone};
// Use the rrule crate imports
use rrule::{RRuleSet, RRule, Frequency};
use crate::{models::event::{Event, EventException, CalendarEventOccurrence}, errors::AppError};
use std::str::FromStr; // Needed for RRuleSet::from_str

// Function to expand an RRULE into occurrences within a date range
pub fn expand_rrule(
    event: &Event, // The base recurring event
    range_start: DateTime<Utc>,
    range_end: DateTime<Utc>,
) -> Result<Vec<CalendarEventOccurrence>, AppError> {
    // Ensure the event has an RRULE
    let rrule_str = event.rrule.as_ref()
        .ok_or_else(|| AppError::InvalidRecurrenceRule("Event does not have an RRULE".into()))?;

    // Parse the RRULE string into an RRuleSet
    // RRuleSet can handle multiple RRULEs, RDATEs, EXRULEs, EXDATEs,
    // but we are currently only storing one RRULE and using our DB table for EXDATE/RECURRENCE-ID logic.
    // We can create a minimal RRuleSet with just our single RRULE.
    let rrule_set = RRuleSet::from_str(rrule_str)
        .map_err(|e| AppError::InvalidRecurrenceRule(format!("Failed to parse RRULE: {}", e)))?;

    // Calculate the duration of the base event
    let duration = event.end_time.signed_duration_since(event.start_time);

    // Iterate through the occurrences generated by the RRuleSet within the desired range
    let occurrences: Vec<CalendarEventOccurrence> = rrule_set
        .into_iter()
        // Filter occurrences to be within our desired range
        .filter(|dt| *dt >= range_start && *dt <= range_end)
        // Map each occurrence datetime to a CalendarEventOccurrence
        .map(|occurrence_start| {
             // The occurrence_start is a DateTime<rrule::Tz>, convert to Utc
            let utc_occurrence_start = occurrence_start.with_timezone(&Utc);

            let occurrence_end = utc_occurrence_start.checked_add_signed(duration)
                 .expect("Failed to calculate occurrence end time. Invalid duration?");

            CalendarEventOccurrence {
                event_id: event.event_id,
                category_id: event.category_id,
                title: event.title.clone(),
                description: event.description.clone(),
                start_time: utc_occurrence_start,
                end_time: occurrence_end,
                location: event.location.clone(),
                original_occurrence_time: Some(utc_occurrence_start), // Store original start time
                exception_id: None,
            }
        })
        .collect();


    Ok(occurrences)
}

// Let's refine expand_rrule to handle DTSTART correctly.
// The `rrule` crate's `RRuleSet::from_str` is primarily for parsing *full iCalendar* content.
// If our DB only stores the RRULE *string*, we need to explicitly tell `rrule` the DTSTART.
// The `RRuleSet` struct has a `dt_start` field.
// A better approach is likely parsing the RRULE string into an `RRule` object,
// putting it in an `RRuleSet`, and setting the `dt_start`.

pub fn expand_rrule_refined(
    event: &Event, // The base recurring event
    range_start: DateTime<Utc>,
    range_end: DateTime<Utc>,
) -> Result<Vec<CalendarEventOccurrence>, AppError> {
    let rrule_str = event.rrule.as_ref()
        .ok_or_else(|| AppError::InvalidRecurrenceRule("Event does not have an RRULE".into()))?;

    // 1. Parse the RRULE string into an RRule object and validate it
    let rrule = RRule::from_str(rrule_str)
        .map_err(|e| AppError::InvalidRecurrenceRule(format!("Failed to parse RRULE string into RRule: {}", e)))?
        .validate(event.start_time.with_timezone(&rrule::Tz::UTC))
        .map_err(|e| AppError::InvalidRecurrenceRule(format!("Failed to validate RRule: {}", e)))?;

    // 2. Create an RRuleSet with the base event's start_time as DTSTART
    // The RRuleSet will use this DTSTART when calculating occurrences
    let mut rrule_set = RRuleSet::new(event.start_time.with_timezone(&rrule::Tz::UTC));
    rrule_set = rrule_set.rrule(rrule);
    // DTSTART is now set during initialization

    // Calculate the duration of the base event
    let duration = event.end_time.signed_duration_since(event.start_time);

     // 3. Iterate through occurrences in the desired range [range_start, range_end]
     // Filter occurrences to be within our desired range and then map them
         let occurrences: Vec<CalendarEventOccurrence> = rrule_set
            .into_iter() // Get the iterator
            // Filter occurrences to be within our desired range
            .filter(|dt| *dt >= range_start.with_timezone(&dt.timezone()) && *dt <= (range_end + Duration::seconds(1)).with_timezone(&dt.timezone()))
            // Map each occurrence datetime to a CalendarEventOccurrence
            .map(|occurrence_start| {
                // Convert the occurrence_start from DateTime<rrule::Tz> to DateTime<Utc>
                let utc_occurrence_start = occurrence_start.with_timezone(&Utc);
    
                let occurrence_end = utc_occurrence_start.checked_add_signed(duration)
                    .expect("Failed to calculate occurrence end time. Invalid duration?");
    
                CalendarEventOccurrence {
                    event_id: event.event_id,
                    category_id: event.category_id,
                    title: event.title.clone(),
                    description: event.description.clone(),
                    start_time: utc_occurrence_start, // Now using converted DateTime<Utc>
                    end_time: occurrence_end,
                    location: event.location.clone(),
                    original_occurrence_time: Some(utc_occurrence_start), // Store original start time
                    exception_id: None,
                }
            })
            .collect();
    
        Ok(occurrences)
    }
    
pub fn apply_exceptions(
    occurrences: &mut Vec<CalendarEventOccurrence>, // Modify the list in place
    exceptions: Vec<EventException>, // Exceptions for this *same* event
) {
    // Use a HashMap for efficient lookup of exceptions by original_occurrence_time
    let exception_map: std::collections::HashMap<DateTime<Utc>, EventException> = exceptions
        .into_iter()
        .map(|ex| (ex.original_occurrence_time, ex))
        .collect();

    // Filter and modify occurrences based on exceptions
    occurrences.retain_mut(|occurrence| {
        // Find if an exception exists for this occurrence's *original* start time
        // NOTE: The `rrule` crate generates occurrences based on the base DTSTART and RRULE.
        // The `original_occurrence_time` in our exception *must* match one of these generated times.
        // If a modified occurrence (exception) itself is moved, its new `start_time` in the exception
        // *is not* the key. The key is the `original_occurrence_time`.
        if let Some(exception) = exception_map.get(&occurrence.original_occurrence_time.unwrap()) { // Use original_occurrence_time
             // Check if the exception is a deletion
            if exception.is_deleted {
                // Remove this occurrence
                return false;
            } else {
                // Apply modifications from the exception
                occurrence.title = exception.title.clone().unwrap_or_else(|| occurrence.title.clone());
                occurrence.description = exception.description.clone().or_else(|| occurrence.description.clone());
                // Use the new start/end time from the exception if provided, otherwise use the calculated occurrence times
                occurrence.start_time = exception.start_time.unwrap_or(occurrence.start_time);
                occurrence.end_time = exception.end_time.unwrap_or(occurrence.end_time);
                occurrence.location = exception.location.clone().or_else(|| occurrence.location.clone());
                occurrence.exception_id = Some(exception.exception_id); // Mark as an exception
            }
        }
        // Keep the occurrence if no exception or it was a modification
        true
    });

}