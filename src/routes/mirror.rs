use axum::{extract::{Path, State}, response::{IntoResponse, Json}, routing::get, Router};
use serde_json::{json, Value};
use http::StatusCode;

use crate::{errors::AppError, state::AppState};


async fn mirror_handler(
    State(state): State<AppState>,
    Path(code): Path<u16>, // Extract the status code from the path
) -> Result<(StatusCode, Json<Value>), AppError> {

    // Try to convert the requested code to a StatusCode
    let status_code = StatusCode::from_u16(code)
        .unwrap_or_else(|_| {
            // If invalid, default to 404 NOT FOUND
            StatusCode::NOT_FOUND
        });

    // Get the canonical reason phrase for this status code
    let reason = status_code.canonical_reason().unwrap_or("Unknown Status Code");
    
    // Special handling for 1xx status codes
    if status_code.is_informational() {
        // 1xx codes are interim responses and can't be properly returned as final responses
        // Return a 200 OK with explanation instead
        let response = json!({
            "requested_status": code,
            "actual_status": 200,
            "message": format!("You requested HTTP {}: {}", code, reason),
            "note": "1xx status codes are interim responses in HTTP and cannot be returned as final responses. Returning 200 OK instead."
        });
        
        return Ok((StatusCode::OK, Json(response)));
    }
    
    // Create a JSON response with the requested status code
    let response = json!({
        "status": status_code.as_u16(),
        "message": format!("You requested HTTP {}: {}", status_code.as_u16(), reason),
        "details": "This response was generated by the status code mirror handler"
    });

    Ok((status_code, Json(response)))
}

pub fn mirror_routes(state: AppState) -> Router {
    Router::new()
        .route("/{code}", get(mirror_handler))
        .with_state(state)
}