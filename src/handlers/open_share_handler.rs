// src/handlers/open_share_handler.rs
use axum::{
    extract::{State, Path, Json},
    http::StatusCode,
};
use sqlx::{PgPool, Transaction, Postgres, types::chrono::Utc};
use validator::Validate;
use crate::{
    AppState,
    errors::AppError,
    models::{
        open_share::{
            OpenCalendarShare, CreateOpenSharePayload, UpdateOpenSharePayload,
            OpenShareDetailsResponse, ListOpenSharesResponseItem, ShareOwnerDetail // Import models
        },
        enums::SharePrivacyLevel,
        user::User, // Need to look up owner user details for response
    },
    middleware::auth::AuthenticatedUser,
};
use chrono::DateTime; // For parsing date strings
use uuid::Uuid;

use crate::utils::calendar::parse_timestamp;

// // Re-use parse_timestamp helper or ensure it's imported from utils
// fn parse_timestamp(s: &str) -> Result<DateTime<Utc>, AppError> {
//     DateTime::parse_from_rfc3339(s)
//         .map(|dt| dt.with_timezone(&Utc))
//         .map_err(|e| {
//             tracing::warn!("Failed to parse timestamp '{}': {}", s, e);
//             AppError::ValidationFailed(validator::ValidationErrors::new())
//         })
// }

// Re-use validate_category_ids helper or ensure it's public/moved to utils
// Assuming validate_category_ids is now `crate::handlers::category_handler::validate_category_ids`
use crate::utils::calendar::validate_category_ids;


// --- Create Open Share (POST /api/me/open-shares) ---
pub async fn create_open_share(
    State(state): State<AppState>,
    AuthenticatedUser { user_id: owner_user_id }: AuthenticatedUser,
    Json(payload): Json<CreateOpenSharePayload>,
) -> Result<(StatusCode, Json<OpenShareDetailsResponse>), AppError> { // Return OpenShareDetailsResponse
    payload.validate()?;

    let category_ids = payload.category_ids.unwrap(); // Required, validated min_length=1
    let privacy_level = payload.privacy_level.unwrap_or_default(); // Defaults to 'fullDetails'
    let expires_at_str = payload.expires_at; // Optional expiry string

    // Parse expires_at date if provided
    let expires_at = match expires_at_str {
        Some(s) if !s.is_empty() => Some(parse_timestamp(&s)?),
        _ => None,
    };

    // 1. Validate that the provided category IDs exist and belong to the owner
    validate_category_ids(&state.pool, owner_user_id, &category_ids).await?;

    // 2. Start a transaction
    let mut tx = state.pool.begin().await?;

    // 3. Insert into open_calendar_shares (UUID is generated by DB default)
    let created_share = sqlx::query_as!(
        OpenCalendarShare,
        r#"
        INSERT INTO open_calendar_shares (owner_user_id, privacy_level, expires_at)
        VALUES ($1, $2, $3)
        RETURNING open_share_id, owner_user_id, privacy_level as "privacy_level!: _",
        expires_at as "expires_at!: _", created_at as "created_at!",
        updated_at as "updated_at!", deleted_at as "deleted_at!: _"
        "#,
        owner_user_id,
        privacy_level as SharePrivacyLevel,
        expires_at,
    )
        .fetch_one(&mut *tx) // Use the transaction with proper dereferencing
        .await?;

    let open_share_id = created_share.open_share_id;

    // 4. Insert into open_calendar_share_categories for each category ID
    for cat_id in &category_ids {
        sqlx::query!(
            r#"
            INSERT INTO open_calendar_share_categories (open_share_id, category_id)
            VALUES ($1, $2)
            "#,
            open_share_id,
            cat_id,
        )
            .execute(&mut *tx) // Use the transaction with proper dereferencing
            .await?;
    }

    // 5. Commit the transaction
    tx.commit().await?;

    // 6. Prepare Response (Fetch the created share with joined owner details and categories)
    // This is similar to the GET by ID query
    let response_share = sqlx::query_as!(
        OpenShareDetailsResponse,
        r#"
        SELECT
            ocs.open_share_id,
            ocs.owner_user_id, -- Direct owner_user_id from ocs
            ocs.privacy_level as "privacy_level!: _",
            ocs.expires_at as "expires_at!: _",
            ocs.created_at as "created_at!",
            ocs.updated_at as "updated_at!",
            ocs.deleted_at as "deleted_at!: _", -- Share's deleted_at
            -- Shared With User Details (aliased)
            u.user_id AS user_id_alias, -- Alias matches struct field name
            u.display_name,
            u.email,
            -- Aggregated Category IDs
            ARRAY_AGG(ocsc.category_id) FILTER (WHERE ocsc.category_id IS NOT NULL) AS "shared_category_ids!: Vec<i32>" -- Use FILTER for empty array
        FROM open_calendar_shares ocs
        JOIN users u ON ocs.owner_user_id = u.user_id -- Join with the owner user
        LEFT JOIN open_calendar_share_categories ocsc ON ocs.open_share_id = ocsc.open_share_id
        WHERE ocs.open_share_id = $1 -- Fetch the specific created share
        GROUP BY ocs.open_share_id, u.user_id -- Group required for array_agg
        "#,
        open_share_id // $1
    )
        .fetch_one(&state.pool) // Use the pool AFTER commit
        .await?;


    Ok((StatusCode::CREATED, Json(response_share)))
}


// --- List Open Shares (GET /api/me/open-shares) ---
// Returns a list of open shares created by the authenticated user
pub async fn list_open_shares(
    State(state): State<AppState>,
    AuthenticatedUser { user_id: owner_user_id }: AuthenticatedUser,
) -> Result<Json<Vec<ListOpenSharesResponseItem>>, AppError> { // Return ListOpenSharesResponseItem

    let shares = sqlx::query_as!(
        ListOpenSharesResponseItem, // Use the response struct
        r#"
        SELECT
            ocs.open_share_id,
            ocs.owner_user_id, -- Direct owner_user_id from ocs
            ocs.privacy_level as "privacy_level!: _",
            ocs.expires_at as "expires_at!: _",
            ocs.created_at as "created_at!",
            ocs.updated_at as "updated_at!",
            ocs.deleted_at as "deleted_at!: _", -- Share's deleted_at

            -- Shared With User Details (aliased)
            u.user_id AS user_id_alias, -- Alias matches struct field name
            u.display_name,
            u.email,

            -- Aggregated Category IDs
            ARRAY_AGG(ocsc.category_id) FILTER (WHERE ocsc.category_id IS NOT NULL) AS "shared_category_ids!: Vec<i32>"
        FROM open_calendar_shares ocs
        JOIN users u ON ocs.owner_user_id = u.user_id
        LEFT JOIN open_calendar_share_categories ocsc ON ocs.open_share_id = ocsc.open_share_id
        WHERE ocs.owner_user_id = $1 -- Filter by the owner user
          AND ocs.deleted_at IS NULL -- Only list non-deleted open shares
        GROUP BY ocs.open_share_id, u.user_id -- Group required for array_agg
        ORDER BY ocs.created_at DESC -- Optional: order by creation date
        "#,
        owner_user_id // $1
    )
        .fetch_all(&state.pool)
        .await?;

    Ok(Json(shares))
}

// --- Get Single Open Share by UUID (Owner View) (GET /api/me/open-shares/:uuid) ---
// Returns details for a specific open share owned by the user
pub async fn get_open_share_by_uuid(
    State(state): State<AppState>,
    AuthenticatedUser { user_id: owner_user_id }: AuthenticatedUser,
    Path(open_share_id): Path<Uuid>, // Extract UUID from path
) -> Result<Json<OpenShareDetailsResponse>, AppError> { // Return OpenShareDetailsResponse

    // Fetch the share with joined data and categories, filtering by UUID AND owner_user_id
    let share = sqlx::query_as!(
        OpenShareDetailsResponse,
        r#"
        SELECT
            ocs.open_share_id,
            ocs.owner_user_id,
            ocs.privacy_level as "privacy_level!: _", ocs.expires_at as "expires_at!: _",
            ocs.created_at as "created_at!", ocs.updated_at as "updated_at!", ocs.deleted_at as "deleted_at!: _",

            -- Shared With User Details (aliased)
            u.user_id AS user_id_alias, -- Alias matches struct field name
            u.display_name,
            u.email,
            ARRAY_AGG(ocsc.category_id) FILTER (WHERE ocsc.category_id IS NOT NULL) AS "shared_category_ids!: Vec<i32>"
        FROM open_calendar_shares ocs
        JOIN users u ON ocs.owner_user_id = u.user_id
        LEFT JOIN open_calendar_share_categories ocsc ON ocs.open_share_id = ocsc.open_share_id
        WHERE ocs.open_share_id = $1 AND ocs.owner_user_id = $2 -- Filter by ID AND owner
          AND ocs.deleted_at IS NULL -- Only get if not soft-deleted
        GROUP BY ocs.open_share_id, u.user_id -- Group required for array_agg
        "#,
        open_share_id, // $1
        owner_user_id  // $2
    )
        .fetch_optional(&state.pool) // Use fetch_optional as it might not exist or belong to user
        .await?;

    match share {
        Some(s) => Ok(Json(s)),
        None => Err(AppError::ShareNotFound), // Re-using ShareNotFound for open shares too
    }
}


// --- Update Open Share (PUT /api/me/open-shares/:uuid) ---
pub async fn update_open_share(
    State(state): State<AppState>,
    AuthenticatedUser { user_id: owner_user_id }: AuthenticatedUser,
    Path(open_share_id): Path<Uuid>, // Extract UUID from path
    Json(payload): Json<UpdateOpenSharePayload>,
) -> Result<Json<OpenShareDetailsResponse>, AppError> { // Return updated OpenShareDetailsResponse
    payload.validate()?;

    // 1. Start a transaction for category updates
    let mut tx = state.pool.begin().await?;

    // 2. Fetch existing open share within the transaction (check ownership, not deleted)
    let existing_share = sqlx::query_as!(
        OpenCalendarShare,
        r#"
        SELECT
            open_share_id, owner_user_id, privacy_level as "privacy_level!: _",
            expires_at as "expires_at!: _", created_at as "created_at!",
            updated_at as "updated_at!", deleted_at as "deleted_at!: _"
        FROM open_calendar_shares
        WHERE open_share_id = $1 AND owner_user_id = $2 AND deleted_at IS NULL
        FOR UPDATE -- Add FOR UPDATE to explicitly lock the row
        "#,
        open_share_id, // $1
        owner_user_id  // $2
    )
        .fetch_optional(&mut *tx)
        .await?;

    let mut share_to_update = match existing_share {
        Some(s) => s,
        None => {
            tx.rollback().await?; // Rollback if not found/owned/deleted
            return Err(AppError::ShareNotFound);
        }
    };

    // 3. Parse expires_at date string if provided in payload
    let mut updated_expires_at = share_to_update.expires_at;
    if payload.expires_at.is_some() || (payload.expires_at.is_none() && payload.expires_at.as_ref().is_some()) {
        updated_expires_at = match payload.expires_at {
            Some(s) if !s.is_empty() => Some(parse_timestamp(&s)?),
            _ => None, // Set to NULL if payload is None or empty string
        };
    }

    // Apply non-category/expiry updates
    if let Some(privacy_level) = payload.privacy_level {
        share_to_update.privacy_level = privacy_level;
    }
    share_to_update.expires_at = updated_expires_at;


    // 4. Handle Category Updates if provided in payload
    if let Some(category_ids) = payload.category_ids {
        // Validate the provided category IDs using the main pool
        validate_category_ids(&state.pool, owner_user_id, &category_ids).await?;

        // Delete existing categories for this share *within the transaction*
        sqlx::query!("DELETE FROM open_calendar_share_categories WHERE open_share_id = $1", open_share_id)
            .execute(&mut *tx)
            .await?;

        // Insert the new set of category IDs *within the transaction*
        for cat_id in &category_ids {
            sqlx::query!(
                r#"
                INSERT INTO open_calendar_share_categories (open_share_id, category_id)
                VALUES ($1, $2)
                "#,
                open_share_id,
                cat_id,
            )
                .execute(&mut *tx)
                .await?;
        }
    }
    // If payload.category_ids was None, categories are unchanged.

    // 5. Perform the update query for the open_calendar_shares table *within the transaction*
    sqlx::query!(
        r#"
        UPDATE open_calendar_shares
        SET
            privacy_level = $1,
            expires_at = $2,
            updated_at = NOW() -- Explicitly update updated_at
        WHERE open_share_id = $3 AND owner_user_id = $4
        "#,
        share_to_update.privacy_level as SharePrivacyLevel,
        share_to_update.expires_at,
        open_share_id,
        owner_user_id
    )
        .execute(&mut *tx)
        .await?;


    // 6. Commit the transaction
    tx.commit().await?;

    // 7. Prepare Response (Fetch the *final* updated share with joined data *outside* the transaction)
    // Same query as GET by UUID (Owner View)
    let response_share = sqlx::query_as!(
        OpenShareDetailsResponse,
        r#"
        SELECT
            ocs.open_share_id,
            ocs.owner_user_id,
            ocs.privacy_level as "privacy_level!: _", ocs.expires_at as "expires_at!: _",
            ocs.created_at as "created_at!", ocs.updated_at as "updated_at!", ocs.deleted_at as "deleted_at!: _",
            -- Shared With User Details (aliased)
            u.user_id AS user_id_alias, -- Alias matches struct field name
            u.display_name,
            u.email,
            ARRAY_AGG(ocsc.category_id) FILTER (WHERE ocsc.category_id IS NOT NULL) AS "shared_category_ids!: Vec<i32>"
        FROM open_calendar_shares ocs
        JOIN users u ON ocs.owner_user_id = u.user_id
        LEFT JOIN open_calendar_share_categories ocsc ON ocs.open_share_id = ocsc.open_share_id
        WHERE ocs.open_share_id = $1 AND ocs.owner_user_id = $2 AND ocs.deleted_at IS NULL
        GROUP BY ocs.open_share_id, u.user_id
        "#,
        open_share_id,
        owner_user_id
    )
        .fetch_one(&state.pool) // Use the main pool AFTER commit
        .await?;

    Ok(Json(response_share))
}


// --- Delete Open Share (Soft) (DELETE /api/me/open-shares/:uuid) ---
pub async fn delete_open_share(
    State(state): State<AppState>,
    AuthenticatedUser { user_id: owner_user_id }: AuthenticatedUser,
    Path(open_share_id): Path<Uuid>, // Extract UUID
) -> Result<StatusCode, AppError> {
    // Perform the soft delete query. Check for user_id!
    let delete_result = sqlx::query!(
        r#"
        UPDATE open_calendar_shares
        SET deleted_at = NOW() -- Soft delete
        WHERE open_share_id = $1 AND owner_user_id = $2 AND deleted_at IS NULL
        "#,
        open_share_id,
        owner_user_id
    )
        .execute(&state.pool)
        .await?;

    if delete_result.rows_affected() == 0 {
        // No rows updated means the share didn't exist, didn't belong to the user, or was already deleted
        Err(AppError::ShareNotFound)
    } else {
        Ok(StatusCode::NO_CONTENT) // 204 No Content
    }
}